# Инструкция
test.xlsx - готовый файл, по желанию можно изменить.

## База данных
В первую очередь **создайте отдельную базу данных** или используйте тестовую,
после чего **поменяйте hibernate.cfg.xml**:
- ```<property name="hibernate.connection.url">jdbc:postgresql://localhost:5432/sber?serverTimezone=Europe/Moscow</property>```
- ```<property name="hibernate.connection.driver_class">org.postgresql.Driver</property>```
- ```<property name="hibernate.connection.username">artur</property>```
- ```<property name="hibernate.connection.password">1234567</property>```
- ```<property name="show_sql">true</property>```


Необходимо изменить ссылку, логин и пароль, по желанию можно установить show_sql = false


## Генерация данных
Класс ```DataGenerator``` отвечает за генерацию, достаточно просто запустить main. Не обязательно генерировать сотрудников, test.xlsx - уже заполненный файл, но если это необходимо, то нужно раскомментировать ```generateAndSaveEmployees``` в методе ```main```.

* ```generateAndSaveCompanies(int companyQuantity, int positionQuantity)``` - метод, генерирующий компании с профессиями и сохраняющий их в бд. 
    - companyQuantity - количество компаний, которые будут сохранены в бд, 
    - positionQuantity - количество профессий в 1 компании
    - VARIATION_IN_PERCENT - поле класса, задающее разброс в процентах, т.е. сейчас 40% (например если мы взяли 5 компаний и 10 профессий, то в итоге будет 5 +-2 компаний и 10 +-4 профессий)


* ```generateAndSaveEmployees(String path, int sheetIdx, int quantity)``` - метод, генерирующий сотрудников и сохраняющий их в .xlsx файл.
    - path - путь до .xlsx файла
    - sheetIdx - номер листа начиная с 0
    - quantity - количество сотрудников, которые будут сгенерированы
## Сохранение данных в БД

```DataManagementService``` - класс ответственный за сохранение данных в бд, необходимо **запустить метод main**.


* ```LAST_ROW``` - ряд, до которого будут просматриваться записи (не включительно), на данный момент записей 500 000, так что перед тем как менять число, нагенерируйте еще данных.
* ```smartSaveAll(int divisionNumber)``` - devisionNumber - количество разбиений, чтобы не вытаскивать сразу 500 тыс. строк, мы разбиваем на 5 частей, можно увеличить разбиение, сократив 
использование оперативной памяти.

## Внимательно
В саму базу данных добавляется не так много значений потому что большинство
не проходит финальную проверку, все данные генерируются случайно, поэтому часто должность и компания сотрудника не совпадают с теми, которые находятся
в базе данных + в 5% случаев специально генерируется неправильный id, для проверки, а также учитывается МРОТ
если сгенерированная зарплата меньше, то мы не кладем данные в бд, полный список ограничений: см. исходное задание

Параметр hibernate.hbm2ddl.auto в hibernate.cfg.xml должен быть установлен на update, иначе компании при перезагрузке будут удаляться

Для меньшего потребления оперативной памяти можно увеличить количество разбиений, уменьшить потребление
памяти самим файлом не получилось, чтобы впринципе работать с excel файлом через ApachePoi api нужно загрузить его в память, также 
не обойтись без текущего списка должностей, иначе не проверить валидность позиции и самой компании (есть ли такая позиция в компании и есть ли вообще такая позиция в бд),
можно каждый раз ходить в бд, но тогда performance сильно упадет, для наглядности я запустил, время работы увеличилось в 10 раз.

Способ с хранением позиций в памяти:
*        Start - 04:06:21
*        End - 04:06:57

Способ с использованием бд при каждой проверки записи из excel%

*        Start - 04:07:48
*        End - 04:12:26 
 
## Замечания 23.01.2024
Сам метод я переписал так, чтобы он в цикле не обращался к БД, это очень сильно бьет по перформансу
(при обращении к бд каждый раз в цикле)

В идеале сделать так: вытаскивать данные в оперативку (все, если возможно), а потом делать один большой batch Insert (insert into ... values ...) используя 1 insert

Если данных слишком много использовать lazyFetch (Jooq) или же бить данные на куски.

По сути это и была изначальная задумка, данные берутся кусками, и кусками сохраняются
НО метод сохранения в бд нужно переписать так, чтобы он делал 1 обращение к БД и сохранял сразу 
список переданных сущностей (сейчас для каждой записи открывается connection)

На данный момент переписал, чтобы не было хотя бы обращений к бд в цикле, но для оптимального перформанса необходимы правки, которые я описал выше.

Помимо этого неплохо было бы настроить более продвинутое логирование, 
сделать свои Exception (и если надо ExceptionHandler - для оповещения пользователей, если сюда прикрутить Spring)


## Исходное задание

#### Приложение на java для парсинга большого excel файла(более 500 000 строк) и сохранения его в БД postgreSql. 

#### Структура файла:
 
id, name, last name, birthday, company, position at work, salary 

#### Валидация: 
1. id, name, last name – обязательные поля 
2. birthday – на момент запуска должен быть старше 18 лет 
3. id – уникальное поле 
4. company – завести таблицу компаний в БД и проверять данные на вхождение в эту таблицу 
5. position at work – аналогично company 


#### Ограничения:
использование оперативной памяти не более 512Мб, java 8+
 
Результат добавить к себе в GitHub c инструкцией для запуска и работы.
